
\chapter{Contract Padawan}

\minitoc

\section{Overview}


In file {\tt Padawan.sol}

\section{Contract Inheritance}


\noindent\begin{tabular}{|l|p{5cm}|}\hline
Base & \\\hline
IEstimateVotesCallback & \\\hline
\end{tabular}


\section{Static Variable Definitions}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
address & \_{}deployer &  \\\hline
 & & used in @2.Padawan.:constructor\\\hline
address & \_{}owner &  \\\hline
 & & used in @2.Padawan.rejectVote\\\hline
 & & used in @2.Padawan.onTokenWalletDeploy\\\hline
 & & used in @2.Padawan.onEstimateVotes\\\hline
 & & used in @2.Padawan.confirmVote\\\hline
 & & used in @2.Padawan.\_{}doReclaim\\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=32]
    address static _deployer;
\end{lstlisting}

\begin{lstlisting}[firstnumber=33]
    address static _owner;
\end{lstlisting}

\section{Variable Definitions}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
mapping (address =$>$ Balance) & \_{}balances &  \\\hline
 & & used in @2.Padawan.updateStatus\\\hline
 & & assigned in @2.Padawan.updateStatus\\\hline
 & & used in @2.Padawan.updateStatus\\\hline
 & & used in @2.Padawan.updateStatus\\\hline
 & & used in @2.Padawan.reclaimDeposit\\\hline
 & & assigned in @2.Padawan.onTokenWalletGetBalance\\\hline
 & & used in @2.Padawan.onTokenWalletGetBalance\\\hline
 & & used in @2.Padawan.onTokenWalletGetBalance\\\hline
 & & assigned in @2.Padawan.onTokenWalletDeploy\\\hline
 & & used in @2.Padawan.onTokenWalletDeploy\\\hline
 & & used in @2.Padawan.onEstimateVotes\\\hline
 & & used in @2.Padawan.onEstimateVotes\\\hline
 & & assigned in @2.Padawan.depositTons\\\hline
 & & used in @2.Padawan.depositTons\\\hline
 & & assigned in @2.Padawan.confirmVote\\\hline
 & & used in @2.Padawan.confirmVote\\\hline
 & & used in @2.Padawan.confirmVote\\\hline
 & & assigned in @2.Padawan.\_{}doReclaim\\\hline
 & & used in @2.Padawan.\_{}doReclaim\\\hline
mapping (address =$>$ address) & \_{}tokenAccounts &  \\\hline
 & & used in @2.Padawan.updateStatus\\\hline
 & & used in @2.Padawan.reclaimDeposit\\\hline
 & & assigned in @2.Padawan.onTokenWalletDeploy\\\hline
 & & used in @2.Padawan.onTokenWalletDeploy\\\hline
 & & used in @2.Padawan.onTokenWalletDeploy\\\hline
 & & used in @2.Padawan.onEstimateVotes\\\hline
 & & used in @2.Padawan.depositTokens\\\hline
 & & used in @2.Padawan.createTokenAccount\\\hline
 & & used in @2.Padawan.confirmVote\\\hline
mapping (address =$>$ ActiveProposal) & \_{}activeProposals &  \\\hline
 & & assigned in @2.Padawan.updateStatus\\\hline
 & & used in @2.Padawan.updateStatus\\\hline
 & & used in @2.Padawan.updateStatus\\\hline
 & & used in @2.Padawan.updateStatus\\\hline
 & & assigned in @2.Padawan.updateStatus\\\hline
 & & used in @2.Padawan.updateStatus\\\hline
 & & used in @2.Padawan.updateStatus\\\hline
 & & assigned in @2.Padawan.rejectVote\\\hline
 & & used in @2.Padawan.rejectVote\\\hline
 & & used in @2.Padawan.rejectVote\\\hline
 & & used in @2.Padawan.reclaimDeposit\\\hline
 & & used in @2.Padawan.reclaimDeposit\\\hline
 & & assigned in @2.Padawan.onEstimateVotes\\\hline
 & & used in @2.Padawan.onEstimateVotes\\\hline
 & & assigned in @2.Padawan.onEstimateVotes\\\hline
 & & used in @2.Padawan.onEstimateVotes\\\hline
 & & used in @2.Padawan.onEstimateVotes\\\hline
 & & used in @2.Padawan.confirmVote\\\hline
uint32 & \_{}activeProposalsLength &  \\\hline
 & & assigned in @2.Padawan.updateStatus\\\hline
 & & used in @2.Padawan.updateStatus\\\hline
 & & assigned in @2.Padawan.rejectVote\\\hline
 & & used in @2.Padawan.rejectVote\\\hline
 & & used in @2.Padawan.reclaimDeposit\\\hline
 & & assigned in @2.Padawan.onEstimateVotes\\\hline
 & & used in @2.Padawan.onEstimateVotes\\\hline
Reclaim & \_{}reclaim &  \\\hline
 & & used in @2.Padawan.updateStatus\\\hline
 & & used in @2.Padawan.updateStatus\\\hline
 & & used in @2.Padawan.updateStatus\\\hline
 & & assigned in @2.Padawan.reclaimDeposit\\\hline
 & & used in @2.Padawan.reclaimDeposit\\\hline
 & & used in @2.Padawan.reclaimDeposit\\\hline
 & & assigned in @2.Padawan.\_{}doReclaim\\\hline
 & & used in @2.Padawan.\_{}doReclaim\\\hline
 & & used in @2.Padawan.\_{}doReclaim\\\hline
 & & used in @2.Padawan.\_{}doReclaim\\\hline
 & & used in @2.Padawan.\_{}doReclaim\\\hline
 & & used in @2.Padawan.\_{}doReclaim\\\hline
 & & used in @2.Padawan.\_{}doReclaim\\\hline
 & & used in @2.Padawan.\_{}doReclaim\\\hline
 & & used in @2.Padawan.\_{}doReclaim\\\hline
 & & used in @2.Padawan.\_{}doReclaim\\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=35]
    mapping(address => Balance) public _balances;
\end{lstlisting}

\begin{lstlisting}[firstnumber=36]
    mapping(address => address) public _tokenAccounts;
\end{lstlisting}

\begin{lstlisting}[firstnumber=37]
    mapping(address => ActiveProposal) public _activeProposals;
\end{lstlisting}

\begin{lstlisting}[firstnumber=38]
    uint32 _activeProposalsLength;
\end{lstlisting}

\begin{lstlisting}[firstnumber=40]
    Reclaim public _reclaim;
\end{lstlisting}

\section{Modifier Definitions}


\subsection{Modifier onlyOwner}


\begin{lstlisting}[firstnumber=44]
    modifier onlyOwner() {
        require(msg.sender == _owner, Errors.NOT_AUTHORIZED_CONTRACT);
        _;
    }
\end{lstlisting}

\section{Constructor Definitions}


\subsection{Constructor}

\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=49]
    constructor() public onlyContract {
        require(_deployer == msg.sender, Errors.ONLY_DEPLOYER);
    }
\end{lstlisting}

\section{Public Method Definitions}


\subsection{Function confirmVote}

\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=89]
    function confirmVote(
        uint128 votes,
        uint128 votePrice,
        address voteProvider)
    external onlyContract { votes;
        optional(ActiveProposal) optActiveProposal = _activeProposals.fetch(msg.sender);
        require(optActiveProposal.hasValue(), 111);
        uint128 activeProposalVotes = optActiveProposal.get().votes;

        address balanceProvider = voteProvider == address(0) ? voteProvider : _tokenAccounts[voteProvider];

        if(_balances[balanceProvider].locked < (activeProposalVotes) * votePrice) {
            _balances[balanceProvider].locked = (activeProposalVotes) * votePrice;
        }
        _owner.transfer(0, false, 64);
    }
\end{lstlisting}

\subsection{Function createTokenAccount}

\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=228]
    function createTokenAccount(address tokenRoot) external onlyOwner {
        require(msg.value >= DEFAULT_FEE, Errors.MSG_VALUE_TOO_LOW);
        require(!_tokenAccounts.exists(tokenRoot));

        ITokenRoot(tokenRoot).deployEmptyWallet
            {value: 0, flag: 64, bounce: true}
            (tvm.functionId(onTokenWalletDeploy), 0, 0, address(this).value, 1 ton);
    }
\end{lstlisting}

\subsection{Function depositTokens}

\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=210]
    function depositTokens(address tokenRoot) external onlyOwner {
        require(msg.value >= DEFAULT_FEE, Errors.MSG_VALUE_TOO_LOW);
        optional(address) optTokenAccount = _tokenAccounts.fetch(tokenRoot);
        require(optTokenAccount.hasValue(), Errors.ACCOUNT_DOES_NOT_EXIST);

        address tokenAccount = optTokenAccount.get();

        ITokenWallet(tokenAccount).getBalance_InternalOwner
            {value: 0, flag: 64, bounce: true}
            (tvm.functionId(onTokenWalletGetBalance));
    }
\end{lstlisting}

\subsection{Function depositTons}

\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=204]
    function depositTons(uint128 tons) external onlyOwner {
        require(msg.value >= tons + 1 ton);
        _balances[address(0)].total += tons;
        // _owner.transfer(0, false, 64);
    }
\end{lstlisting}

\subsection{Function onEstimateVotes}

\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=60]
    function onEstimateVotes(
        uint128 cost,
        uint128 votePrice,
        address voteProvider,
        uint128 votes,
        bool choice)
    external override onlyContract {
        optional(ActiveProposal) optActiveProposal = _activeProposals.fetch(msg.sender);
        ActiveProposal activeProposal = optActiveProposal.hasValue() ? optActiveProposal.get() : ActiveProposal(voteProvider, votePrice, 0);
        if(!optActiveProposal.hasValue()) {
            _activeProposals[msg.sender] = activeProposal;
        }
        optional(Balance) optBalance;
        if(voteProvider == address(0)) {
            optBalance = _balances.fetch(voteProvider);
        } else {
            optional(address) optAccount = _tokenAccounts.fetch(voteProvider);
            require(optAccount.hasValue(), 115);
            optBalance = _balances.fetch(optAccount.get());
        }
        require(optBalance.hasValue(), 113);
        require(optBalance.get().total >= (activeProposal.votes * votePrice) + cost, 114);
        _activeProposals[msg.sender].votes += votes;
        _activeProposalsLength += 1;
        IProposal(msg.sender).vote
            {value: 0, flag: 64, bounce: true}
            (_owner, choice, votes);
    }
\end{lstlisting}

\subsection{Function onTokenWalletDeploy}

\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=237]
    function onTokenWalletDeploy(address account) public {
        require(!_tokenAccounts.exists(msg.sender), Errors.INVALID_CALLER);
        _tokenAccounts[msg.sender] = account;
        _balances[account] = Balance(0, 0);
        _owner.transfer(0, false, 64);
    }
\end{lstlisting}

\subsection{Function onTokenWalletGetBalance}

\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=222]
    function onTokenWalletGetBalance(uint128 balance) public onlyContract {
        optional(Balance) optBalance = _balances.fetch(msg.sender);
        require(optBalance.hasValue(), Errors.NOT_AUTHORIZED_CONTRACT);
        _balances[msg.sender].total += balance;
    }
\end{lstlisting}

\subsection{Function reclaimDeposit}

\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=118]
    function reclaimDeposit(address voteProvider, uint128 amount, address returnTo) external onlyOwner {
        require(_reclaim.amount == 0, 130);
        require(msg.value >= QUERY_STATUS_FEE * _activeProposalsLength + 1 ton, Errors.MSG_VALUE_TOO_LOW);
        address balanceProvider = address(0);
        if(voteProvider != address(0)) {
            optional(address) optAccount = _tokenAccounts.fetch(voteProvider);
            require(optAccount.hasValue(), 117);
            balanceProvider = optAccount.get();
        }
        optional(Balance) optBalance = _balances.fetch(balanceProvider);
        require(optBalance.hasValue(), 131);
        Balance balance = optBalance.get();
        require(amount <= balance.total, Errors.NOT_ENOUGH_VOTES);
        require(returnTo != address(0), 132);

        _reclaim = Reclaim(balanceProvider, amount, returnTo);

        if (amount <= balance.total - balance.locked) {
            _doReclaim();
        }

        optional(address, ActiveProposal) optActiveProposal = _activeProposals.min();
        while (optActiveProposal.hasValue()) {
            (address addrActiveProposal,) = optActiveProposal.get();
            IProposal(addrActiveProposal).queryStatus
                {value: QUERY_STATUS_FEE, bounce: true, flag: 1}
                ();
            optActiveProposal = _activeProposals.next(addrActiveProposal);
        }
    }
\end{lstlisting}

\subsection{Function rejectVote}

\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=106]
    function rejectVote(uint128 votes, uint16 errorCode) external onlyContract { votes; errorCode;
        optional(ActiveProposal) optActiveProposal = _activeProposals.fetch(msg.sender);
        require(optActiveProposal.hasValue(), 112);
        ActiveProposal activeProposal = optActiveProposal.get();
        activeProposal.votes -= votes;
        if (activeProposal.votes == 0) {
            delete _activeProposals[msg.sender];
            _activeProposalsLength -= 1;
        }
        _owner.transfer(0, false, 64);
    }
\end{lstlisting}

\subsection{Function updateStatus}

\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=149]
    function updateStatus(ProposalState state) external onlyContract {
        optional(ActiveProposal) optActiveProposal = _activeProposals.fetch(msg.sender);
        require(optActiveProposal.hasValue());
        ActiveProposal activeProposal = optActiveProposal.get();

        if (state >= ProposalState.Ended) {
            address balanceProvider = address(0);
            if(activeProposal.voteProvider != address(0)) {
                optional(address) optAccount = _tokenAccounts.fetch(activeProposal.voteProvider);
                require(optAccount.hasValue(), 117);
                balanceProvider = optAccount.get();
            }
            Balance balance = _balances[balanceProvider];
            if(balance.locked <= activeProposal.votes * activeProposal.votePrice) {
                delete _activeProposals[msg.sender];
                uint128 max;
                optional(address, ActiveProposal) optActiveProposal2 = _activeProposals.min();
                while (optActiveProposal2.hasValue()) {
                    (address addrActiveProposal, ActiveProposal activeProposal2) = optActiveProposal2.get();
                    if(activeProposal2.votes * activeProposal2.votePrice > max && activeProposal2.voteProvider == activeProposal.voteProvider) {
                        max = activeProposal2.votes * activeProposal2.votePrice;
                    }
                    optActiveProposal2 = _activeProposals.next(addrActiveProposal);
                }
                _balances[balanceProvider].locked = max;
            } else {
                delete _activeProposals[msg.sender];
            }
            _activeProposalsLength -= 1;
            if(_reclaim.amount != 0) {
                balance = _balances[_reclaim.balanceProvider];
                if (_reclaim.amount <= balance.total - balance.locked) {
                    _doReclaim();
                }
            }
        }
    }
\end{lstlisting}

\subsection{Function vote}

\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=53]
    function vote(address proposal, bool choice, uint128 votes) external onlyOwner {
        require(msg.value >= VOTE_FEE, Errors.MSG_VALUE_TOO_LOW);
        IProposal(proposal).estimateVotes
            {value: 0, flag: 64, bounce: true}
            (votes, choice);
    }
\end{lstlisting}

\section{Internal Method Definitions}


\subsection{Function \_{}doReclaim}

\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=191]
    function _doReclaim() private inline {
        if(_reclaim.balanceProvider == address(0)) {
            _reclaim.returnTo.transfer(_reclaim.amount, true, 1);
        } else {
            ITokenWallet(_reclaim.balanceProvider).transfer
                {value: 0.2 ton} // refactor
                (_reclaim.returnTo, _reclaim.amount, 0.1 ton);
        }
        _balances[_reclaim.balanceProvider].total -= _reclaim.amount;
        delete _reclaim;
        _owner.transfer(0, false, 64);
    }
\end{lstlisting}
