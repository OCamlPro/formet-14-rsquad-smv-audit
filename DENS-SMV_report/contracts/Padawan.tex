
\chapter{Contract Padawan}

\minitoc

\section{Overview}

In file {\tt Padawan.sol}

This contract is used by a user to collect his voting rights (within a
token wallet), and vote for proposals. Voting rights can be added, and
reclaimed if not currently used.

\section{Static Variable Definitions}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=18]
    address static _deployer;
\end{lstlisting}

\begin{lstlisting}[firstnumber=19]
    address static _owner;
\end{lstlisting}

\section{Variable Definitions}

\begin{itemize}
\item Minor issue: there is no function to clean {\tt
  \_activeProposals}, i.e. to remove proposals that are
  ended. Currently, it is possible to use {\tt reclaimDeposit} with
  argument 0 to do that. It would be better to introduce a {\tt
    cleanProposals} function for that purpose.
\end{itemize}

\begin{lstlisting}[firstnumber=21]
    address _addrTokenRoot;
\end{lstlisting}

\begin{lstlisting}[firstnumber=23]
    TipAccount _tipAccount;
\end{lstlisting}

\begin{lstlisting}[firstnumber=24]
    address _returnTo;
\end{lstlisting}

\begin{lstlisting}[firstnumber=26]
    mapping(address => uint32) _activeProposals;
\end{lstlisting}

\begin{lstlisting}[firstnumber=28]
    uint32 _requestedVotes;
\end{lstlisting}

\begin{lstlisting}[firstnumber=29]
    uint32 _totalVotes;
\end{lstlisting}

\begin{lstlisting}[firstnumber=30]
    uint32 _lockedVotes;
\end{lstlisting}

\section{Modifier Definitions}


\subsection{Modifier onlyOwner}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=34]
    modifier onlyOwner() {
        require(msg.sender == _owner, Errors.NOT_AUTHORIZED_CONTRACT);
        _;
    }
\end{lstlisting}

\subsection{Modifier onlyTokenRoot}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=39]
    modifier onlyTokenRoot() {
        require(msg.sender == _addrTokenRoot, Errors.INVALID_CALLER);
        _;
    }
\end{lstlisting}

\section{Constructor Definitions}


\subsection{Constructor}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=46]
    constructor(address addrTokenRoot) public onlyContract {
        require(_deployer == msg.sender, Errors.ONLY_DEPLOYER);
        _addrTokenRoot = addrTokenRoot;
        _createTokenAccount();
    }
\end{lstlisting}

\section{Public Method Definitions}


\subsection{Function confirmVote}

\begin{itemize}
\item Minor issue: there is no real reason to call {\tt
  \_updateLockedVotes} here, as it could be called in {\tt
  reclaimDeposit} instead. Indeed, {\tt \_lockedVotes} is only used
  when the deposit is reclaimed, so it will save the cost of the
  recomputation if the user votes for many proposals without
  reclaiming his tokens.
\end{itemize}

\begin{lstlisting}[firstnumber=74]
    function confirmVote(uint32 votesCount) external onlyContract {
        // TODO: better to check is it proposal or not
        optional(uint32) optActiveProposal = _activeProposals.fetch(msg.sender);
        require(optActiveProposal.hasValue());

        _activeProposals[msg.sender] += votesCount;
        
        _updateLockedVotes();

        _owner.transfer(0, false, 64);
    }
\end{lstlisting}

\subsection{Function depositTokens}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=172]
    function depositTokens() external onlyOwner view {
        require(msg.value >= DEPOSIT_TOKENS_FEE, Errors.MSG_VALUE_TOO_LOW);
        require(_tipAccount.addr != address(0), Errors.ACCOUNT_DOES_NOT_EXIST);

        ITokenWallet(_tipAccount.addr).getBalance_InternalOwner
            {value: 0, flag: 64, bounce: true}
            (tvm.functionId(onGetBalance));
    }
\end{lstlisting}

\subsection{Function getActiveProposals}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=228]
    function getActiveProposals() public view returns (mapping(address => uint32) activeProposals) {
        activeProposals = _activeProposals;
    }
\end{lstlisting}

\subsection{Function getAddresses}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=224]
    function getAddresses() public view returns (address ownerAddress) {
        ownerAddress = _owner;
    }
\end{lstlisting}

\subsection{Function getAll}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=207]
    function getAll() external view returns (TipAccount tipAccount, uint32 reqVotes, uint32 totalVotes, uint32 lockedVotes) {
        tipAccount = _tipAccount;
        reqVotes = _requestedVotes;
        totalVotes =  _totalVotes;
        lockedVotes = _lockedVotes;
    }
\end{lstlisting}

\subsection{Function getTipAccount}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=214]
    function getTipAccount() external view returns (TipAccount tipAccount) {
        tipAccount = _tipAccount;
    }
\end{lstlisting}

\subsection{Function getVoteInfo}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=218]
    function getVoteInfo() external view returns (uint32 reqVotes, uint32 totalVotes, uint32 lockedVotes) {
        reqVotes = _requestedVotes;
        totalVotes =  _totalVotes;
        lockedVotes = _lockedVotes;
    }
\end{lstlisting}

\subsection{Function onGetBalance}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=181]
    function onGetBalance(uint128 balance) public onlyContract {
        require(_tipAccount.addr == msg.sender, Errors.NOT_AUTHORIZED_CONTRACT);
        _tipAccount.balance = balance;
        _totalVotes = uint32(balance);
        _owner.transfer(0, false, 64);
    }
\end{lstlisting}

\subsection{Function onTokenWalletDeploy}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=192]
    function onTokenWalletDeploy(address ownerAddress) public onlyTokenRoot {
        _tipAccount = TipAccount(ownerAddress, 0);
        _owner.transfer(0, false, 64);
    }
\end{lstlisting}

\subsection{Function reclaimDeposit}

\begin{itemize}
\item Minor issue: the user might want to use {\tt votes=0} to cancel
  a withdrawal. In this case, this function should skip sending all
  {\tt queryStatus} messages, unless the goal is to clean the {\tt
    \_activeProposals} mapping (we advise to create a function for that
  purpose).
\item Minor issue: there is no reason to send {\tt queryStatus}
  messages if the {\tt \_unlockDeposit} function was called, i.e. if
  the reclaim was already successful
\end{itemize}

\begin{lstlisting}[firstnumber=103]
    function reclaimDeposit(uint32 votes, address returnTo) external onlyOwner {
        require(msg.value >= 3 ton, Errors.MSG_VALUE_TOO_LOW);
        require(votes <= _totalVotes, Errors.NOT_ENOUGH_VOTES);
        require(returnTo != address(0));
        _returnTo = returnTo;
        _requestedVotes = votes;

        if (_requestedVotes <= _totalVotes - _lockedVotes) {
            _unlockDeposit();
        } else {
            _requestedVotes = 0;
        }

        optional(address, uint32) optActiveProposal = _activeProposals.min();
        while (optActiveProposal.hasValue()) {
            (address addrActiveProposal,) = optActiveProposal.get();
            IProposal(addrActiveProposal).queryStatus
                {value: QUERY_STATUS_FEE, bounce: true, flag: 1}
                ();
            optActiveProposal = _activeProposals.next(addrActiveProposal);
        }
    }
\end{lstlisting}

\subsection{Function rejectVote}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=87]
    function rejectVote(uint32 votesCount, uint16 errorCode) external onlyContract {
        votesCount; errorCode;

        // TODO: better to check is it proposal or not
        optional(uint32) optActiveProposal = _activeProposals.fetch(msg.sender);
        require(optActiveProposal.hasValue());
        uint32 activeProposalVotes = optActiveProposal.get();
        if (activeProposalVotes == 0) {
            delete _activeProposals[msg.sender];
        }

        _owner.transfer(0, false, 64);
    }
\end{lstlisting}

\subsection{Function updateStatus}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=127]
    function updateStatus(ProposalState state) external onlyContract {
        optional(uint32) optActiveProposal = _activeProposals.fetch(msg.sender);
        require(optActiveProposal.hasValue());
        tvm.accept();

        if (state >= ProposalState.Ended) {
            delete _activeProposals[msg.sender];
            _updateLockedVotes();
        }

        if (_requestedVotes != 0 && _requestedVotes <= _totalVotes - _lockedVotes) {
            _unlockDeposit();
        }
    }
\end{lstlisting}

\subsection{Function vote}

\begin{itemize}
\item \issueCritical{Unlimited voting rights in {\tt Padawan.vote}}{An
  attacker can call this method several times in the same round and in
  consecutive rounds to vote several times for the same proposal,
  until the {\tt Padawan.confirmVote} message is received. Fix: voting
  rights should be immediately decreased instead of waiting for {\tt
    confirmVote}.}
\item \issueMajor{Infinite locking of deposits in {\tt
    Padawan.vote}}{An attacker could send a faked proposal address to
  a user to make him vote for a non-existing proposal. It can generate
  a little increase in storage, but if the fix of the critical issue
  above is done, it could also lock the deposits forever, as the
  corresponding contract will never end and unlock the deposits. Fix:
  this method should take the title of the proposal in argument,
  computes the address of the proposal, and the contract should
  correctly deal with bounced messages.}
\end{itemize}

\begin{lstlisting}[firstnumber=55]
    function vote(address proposal, bool choice, uint32 votes) external onlyOwner {
        require(msg.value >= VOTE_FEE, Errors.MSG_VALUE_TOO_LOW);
        optional(uint32) optActiveProposal = _activeProposals.fetch(proposal);

        uint32 activeProposalVotes = optActiveProposal.hasValue() ? optActiveProposal.get() : 0;
        uint32 availableVotes = _totalVotes - activeProposalVotes;
        require(votes <= availableVotes, Errors.NOT_ENOUGH_VOTES);

        // TODO: better to remove
        if (activeProposalVotes == 0) {
            _activeProposals[proposal] = 0;
        }
        
        IProposal(proposal).vote
            {value: 0, flag: 64, bounce: true}
            (_owner, choice, votes);
    }
\end{lstlisting}

\section{Internal Method Definitions}


\subsection{Function \_{}createTokenAccount}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=197]
    function _createTokenAccount() private view {
        ITokenRoot(_addrTokenRoot).deployEmptyWallet
            {value: 2 ton, flag: 1, bounce: true}
            (tvm.functionId(onTokenWalletDeploy), 0, 0, address(this).value, 1 ton);
    }
\end{lstlisting}

\subsection{Function \_{}unlockDeposit}

\begin{itemize}
\item Minor issue: this function should skip sending a message if {\tt
  \_requestedVotes} is 0.
\end{itemize}

\begin{lstlisting}[firstnumber=146]
    function _unlockDeposit() private {
        ITokenWallet(_tipAccount.addr).transfer
            {value: 0.1 ton + 0.1 ton}
            (_returnTo, _requestedVotes, 0.1 ton);
        _totalVotes -= _requestedVotes;
        _requestedVotes = 0;
        _returnTo = address(0);
    }
\end{lstlisting}

\subsection{Function \_{}updateLockedVotes}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=155]
    function _updateLockedVotes() private inline {
        optional(address, uint32) optActiveProposal = _activeProposals.min();
        uint32 lockedVotes;
        while (optActiveProposal.hasValue()) {
            (address addr, uint32 votes) = optActiveProposal.get();
            if (votes > lockedVotes) {
                lockedVotes = votes;
            }
            optActiveProposal = _activeProposals.next(addr);
        }
        _lockedVotes = lockedVotes;
    }
\end{lstlisting}
